#include "config.h"
#include "cunit/cunit.h"
#include "xmalloc.h"
#include "util.h"
#include "retry.h"
#include "libcyr_cfg.h"
#include "imap/mboxlist.h"
#include "imap/search_engines.h"

#define DBDIR		"test-mb-dbdir"
#define MBOXNAME1_INT   "user.smurf"
#define PARTITION	"default"
#define ACL		"anyone\tlrswipkxtecdan\t"

/* Test the output of the search builder. */
static void test_builder(void)
{
    int r;
    struct mailbox *mailbox = NULL;
#define BEGIN \
    { \
	search_builder_t *bx = search_begin_search(mailbox, 0); \
	CU_ASSERT_PTR_NOT_NULL(bx)
#define END(exp) \
	{ \
	    static const char _exp[] = (exp); \
	    void *intquery = bx->get_internalised(bx); \
	    char *s = search_describe_internalised(intquery); \
	    CU_ASSERT_STRING_EQUAL(s, _exp); \
	    free(s); \
	    search_free_internalised(intquery); \
	} \
	search_end_search(bx); \
    }

    r = mailbox_open_iwl(MBOXNAME1_INT, &mailbox);
    CU_ASSERT_EQUAL_FATAL(r, 0);

    /* Test the various SEARCH_PART_* constants */
    BEGIN;
    bx->match(bx, SEARCH_PART_ANY, "etsy");
    END("\"etsy\"");

    BEGIN;
    bx->match(bx, SEARCH_PART_FROM, "quinoa");
    END("@header_from \"quinoa\"");

    BEGIN;
    bx->match(bx, SEARCH_PART_TO, "dreamcatcher");
    END("@header_to \"dreamcatcher\"");

    BEGIN;
    bx->match(bx, SEARCH_PART_CC, "cosby");
    END("@header_cc \"cosby\"");

    BEGIN;
    bx->match(bx, SEARCH_PART_BCC, "mcsweeneys");
    END("@header_bcc \"mcsweeneys\"");

    BEGIN;
    bx->match(bx, SEARCH_PART_SUBJECT, "locavore");
    END("@header_subject \"locavore\"");

    BEGIN;
    bx->match(bx, SEARCH_PART_HEADERS, "mumblecore");
    END("@headers \"mumblecore\"");

    BEGIN;
    bx->match(bx, SEARCH_PART_BODY, "narwhal");
    END("@body \"narwhal\"");

    /* Test simple boolean ops with obvious numbers of children */
    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_AND);
    bx->match(bx, SEARCH_PART_ANY, "godard");
    bx->match(bx, SEARCH_PART_ANY, "anderson");
    bx->end_boolean(bx, SEARCH_OP_AND);
    END("\"godard\" \"anderson\"");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_OR);
    bx->match(bx, SEARCH_PART_ANY, "skateboard");
    bx->match(bx, SEARCH_PART_ANY, "keffiyeh");
    bx->end_boolean(bx, SEARCH_OP_OR);
    END("\"skateboard\"|\"keffiyeh\"");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_NOT);
    bx->match(bx, SEARCH_PART_ANY, "typewriter");
    bx->end_boolean(bx, SEARCH_OP_NOT);
    END("!\"typewriter\"");

    /* Test boolean ops with unusual numbers of children */
    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_AND);
    /* zero children */
    bx->end_boolean(bx, SEARCH_OP_AND);
    END("");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_AND);
    /* one child */
    bx->match(bx, SEARCH_PART_ANY, "tumblr");
    bx->end_boolean(bx, SEARCH_OP_AND);
    END("\"tumblr\"");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_AND);
    /* the Brady bunch */
    bx->match(bx, SEARCH_PART_ANY, "you");
    bx->match(bx, SEARCH_PART_ANY, "probably");
    bx->match(bx, SEARCH_PART_ANY, "havent");
    bx->match(bx, SEARCH_PART_ANY, "heard");
    bx->match(bx, SEARCH_PART_ANY, "of");
    bx->match(bx, SEARCH_PART_ANY, "them");
    bx->end_boolean(bx, SEARCH_OP_AND);
    END("\"you\" \"probably\" \"havent\" \"heard\" \"of\" \"them\"");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_OR);
    /* zero children */
    bx->end_boolean(bx, SEARCH_OP_OR);
    END("");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_OR);
    /* one child */
    bx->match(bx, SEARCH_PART_ANY, "tumblr");
    bx->end_boolean(bx, SEARCH_OP_OR);
    END("\"tumblr\"");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_OR);
    /* the Brady bunch */
    bx->match(bx, SEARCH_PART_ANY, "you");
    bx->match(bx, SEARCH_PART_ANY, "probably");
    bx->match(bx, SEARCH_PART_ANY, "havent");
    bx->match(bx, SEARCH_PART_ANY, "heard");
    bx->match(bx, SEARCH_PART_ANY, "of");
    bx->match(bx, SEARCH_PART_ANY, "them");
    bx->end_boolean(bx, SEARCH_OP_OR);
    END("\"you\"|\"probably\"|\"havent\"|\"heard\"|\"of\"|\"them\"");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_NOT);
    /* zero children */
    bx->end_boolean(bx, SEARCH_OP_NOT);
    END("");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_NOT);
    /* one child */
    bx->match(bx, SEARCH_PART_ANY, "tumblr");
    bx->end_boolean(bx, SEARCH_OP_NOT);
    END("!\"tumblr\"");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_NOT);
    /* the Brady bunch */
    bx->match(bx, SEARCH_PART_ANY, "you");
    bx->match(bx, SEARCH_PART_ANY, "probably");
    bx->match(bx, SEARCH_PART_ANY, "havent");
    bx->match(bx, SEARCH_PART_ANY, "heard");
    bx->match(bx, SEARCH_PART_ANY, "of");
    bx->match(bx, SEARCH_PART_ANY, "them");
    bx->end_boolean(bx, SEARCH_OP_NOT);
    END("!(\"you\" \"probably\" \"havent\" \"heard\" \"of\" \"them\")");

    /* sensible combinations of booleans */
    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_OR);
	bx->begin_boolean(bx, SEARCH_OP_AND);
	    bx->match(bx, SEARCH_PART_ANY, "wayfarers");
	    bx->match(bx, SEARCH_PART_ANY, "messengerbag");
	bx->end_boolean(bx, SEARCH_OP_AND);
	bx->begin_boolean(bx, SEARCH_OP_AND);
	    bx->match(bx, SEARCH_PART_ANY, "jeanshorts");
	    bx->match(bx, SEARCH_PART_ANY, "fannypack");
	bx->end_boolean(bx, SEARCH_OP_AND);
    bx->end_boolean(bx, SEARCH_OP_OR);
    END("(\"wayfarers\" \"messengerbag\")|(\"jeanshorts\" \"fannypack\")");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_AND);
	bx->begin_boolean(bx, SEARCH_OP_OR);
	    bx->match(bx, SEARCH_PART_ANY, "mixtape");
	    bx->match(bx, SEARCH_PART_ANY, "pinterest");
	bx->end_boolean(bx, SEARCH_OP_OR);
	bx->begin_boolean(bx, SEARCH_OP_OR);
	    bx->match(bx, SEARCH_PART_ANY, "vinyl");
	    bx->match(bx, SEARCH_PART_ANY, "etsy");
	bx->end_boolean(bx, SEARCH_OP_OR);
    bx->end_boolean(bx, SEARCH_OP_AND);
    END("\"mixtape\"|\"pinterest\" \"vinyl\"|\"etsy\"");

    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_OR);
	bx->match(bx, SEARCH_PART_ANY, "tobe");
	bx->begin_boolean(bx, SEARCH_OP_NOT);
	    bx->match(bx, SEARCH_PART_ANY, "tobe");
	bx->end_boolean(bx, SEARCH_OP_NOT);
    bx->end_boolean(bx, SEARCH_OP_OR);
    END("\"tobe\"|!\"tobe\"");

    /* IRIS-2012 */
    BEGIN;
    bx->begin_boolean(bx, SEARCH_OP_AND);
	bx->begin_boolean(bx, SEARCH_OP_OR);
	    bx->begin_boolean(bx, SEARCH_OP_AND);
		bx->match(bx, SEARCH_PART_FROM, "MARIANH");
		bx->match(bx, SEARCH_PART_SUBJECT, "TEST");
	    bx->end_boolean(bx, SEARCH_OP_AND);
	    bx->begin_boolean(bx, SEARCH_OP_AND);
	    bx->end_boolean(bx, SEARCH_OP_AND);
	bx->end_boolean(bx, SEARCH_OP_OR);
    bx->end_boolean(bx, SEARCH_OP_AND);
    END("@header_from \"MARIANH\" @header_subject \"TEST\"");

    mailbox_close(&mailbox);
#undef BEGIN
#undef END
}

static void config_read_string(const char *s)
{
    char *fname = xstrdup("/tmp/cyrus-cunit-configXXXXXX");
    int fd = mkstemp(fname);
    retry_write(fd, s, strlen(s));
    config_reset();
    config_read(fname, 0);
    unlink(fname);
    free(fname);
    close(fd);
}

static int fexists(const char *fname)
{
    struct stat sb;
    int r;

    r = stat(fname, &sb);
    if (r < 0)
	r = -errno;
    return r;
}

static int set_up(void)
{
    int r;
    struct mboxlist_entry mbentry;
    struct mailbox *mailbox;
    const char * const *d;
    static const char * const dirs[] = {
	DBDIR,
	DBDIR"/db",
	DBDIR"/conf",
	DBDIR"/data",
	DBDIR"/data/user",
	DBDIR"/data/user/smurf",
	DBDIR"/data/user/smurfette",
	NULL
    };

    r = system("rm -rf " DBDIR);
    if (r)
	return r;

    r = fexists(DBDIR);
    if (r != -ENOENT)
	return ENOTDIR;

    for (d = dirs ; *d ; d++) {
	r = mkdir(*d, 0777);
	if (r < 0) {
	    int e = errno;
	    perror(*d);
	    return e;
	}
    }

    libcyrus_config_setstring(CYRUSOPT_CONFIG_DIR, DBDIR);

    config_read_string(
	"configdirectory: "DBDIR"/conf\n"
	"defaultpartition: "PARTITION"\n"
	"partition-"PARTITION": "DBDIR"/data\n"
	"mboxlist_db: skiplist\n"
	"quota_db: skiplist\n"
	"search_engine: sphinx\n"
    );

    cyrusdb_init();

    quotadb_init(0);
    quotadb_open(NULL);

    mboxlist_init(0);
    mboxlist_open(NULL);

    memset(&mbentry, 0, sizeof(mbentry));
    mbentry.name = MBOXNAME1_INT;
    mbentry.mbtype = 0;
    mbentry.partition = PARTITION;
    mbentry.acl = ACL;
    r = mboxlist_update(&mbentry, /*localonly*/1);
    if (r)
	return r;

    r = mailbox_create(MBOXNAME1_INT, PARTITION, ACL,
		       /*uniqueid*/NULL, /*specialuse*/NULL,
		       /*options*/0, /*uidvalidity*/0,
		       /*highestmodseq*/0, &mailbox);
    if (r)
	return r;

    mailbox_close(&mailbox);

    return 0;
}

static int tear_down(void)
{
    mboxlist_close();
    mboxlist_done();

    quotadb_close();
    quotadb_done();

    cyrusdb_done();
    config_reset();

    (void)system("rm -rf " DBDIR);

    return 0;
}

/* vim: set ft=c: */
